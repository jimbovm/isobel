package com.github.jimbovm.isobel.bytecode.common;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.lang3.ArrayUtils;

import com.github.jimbovm.isobel.actor.Actor;
import com.github.jimbovm.isobel.actor.PageSkip;

/**
 * Factors out common functionality for unparsing collections of
 * actor objects into the in-game bytecode required to spawn them.
 */
public abstract class BytecodeUnparser<T extends Actor> {

	private int endMarker;

	/** 
	 * Create a new bytecode unparser.
	 *
	 * @param endMarker The byte that marks end of input.
	 */
	public BytecodeUnparser(final int endMarker) {
		this.endMarker = endMarker;
	}

	/**
	 * Return the bytecode equivalent of the data's header, 
	 * or <code>null</code> if there is no header.
	 * 
	 * @return A two-byte array or <code>null</code>.
	 */
	protected abstract byte[] unparseHeader();

	/**
	 * Unparse a {@link com.github.jimbovm.isobel.actor.PageSkip} instance to 
	 * bytecode.
	 * 
	 * @param skip The page skip to unparse.
	 * @param newPage Whether to set the new page flag in the generated bytecode.
	 * @return An array of the bytecode to spawn the page skip.
	 */
	protected abstract byte[] unparsePageSkip(final PageSkip skip, final boolean newPage);

	/**
	 * Unparse a list of actor objects of type <code>T</code> to bytecode.
	 * 
	 * @param actors A {@link List} of actor objects. 
	 * @return A byte array of the bytecode commands to spawn their respective actors.
	 */
	public byte[] unparse(List<T> actors) {

		LinkedList<T> sortedActors = new LinkedList<T>(actors);
		Collections.sort(sortedActors);

		List<Byte> bytecode = new LinkedList<>();

		byte[] headerBytes = unparseHeader();

		// Only geography data has a header
		if (headerBytes != null) {
			for (byte headerByte : headerBytes) {
				bytecode.add(headerByte);
			}
		}

		// We keep track of this for working with page skips
		int currentPage = 0;

		int lastX = 0;

		/* We are working with absolute coordinates right down
		 * to the point where we unparse a command from an actor.
		 * We keep track of what page we're on and work out if each 
		 * actor is the first on its page as we go, inserting skips
		 * if necessary.
		 */
		for (T actor : sortedActors) {

			boolean newPage = false;

			// Are we over the boundary of the current page?
			int currentPageBoundary = currentPage + (15 * (currentPage + 1));
			int distanceFromBoundary = currentPageBoundary - actor.getX();

			// If distance from the boundary is negative, yes
			newPage = (distanceFromBoundary < 0);
			if (newPage) {
				// We are at least one page ahead of the last actor, but how many?
				int pagesAhead = (actor.getX() / 16) - currentPage;

				// If more than one, we need to insert a skip command
				if (pagesAhead > 1) {
					int targetPage = currentPage + pagesAhead;
					PageSkip skip = new PageSkip();
					skip.setX(lastX);
					skip.setTarget(targetPage);
					for (byte b : this.unparsePageSkip(skip, false)) {
						bytecode.add(b);
					}
					// We know the actor comes next
					newPage = false;
					// Make a note of what we just did
					currentPage = targetPage;
				} else {
					// Otherwise, just increment the page counter
					currentPage++;
				}

				lastX = actor.getX();
			}

			// We're now clear to unparse the actor and add it to the array
			final byte[] newBytecode = unparse(actor, newPage);
			for (byte b : newBytecode) {
				bytecode.add(b);
			}
		}

		// Done unparsing to commands; write the EOF marker
		bytecode.add((byte) endMarker);
		
		Byte[] output = new Byte[bytecode.size()];
		for (int i = 0; i < output.length; i++) {
			output[i] = bytecode.get(i);
		}

		return ArrayUtils.toPrimitive(output);
	}

	/**
	 * Unparse an actor of type <code>T</code> to bytecode.
	 * 
	 * @param actor The actor to unparse.
	 * @param newPage Whether to set the new page flag in the generated bytecode.
	 * @return An array of the bytecode required to spawn the actor.
	 */
	protected abstract byte[] unparse(T actor, boolean newPage);
}
